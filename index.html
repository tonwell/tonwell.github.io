<h1 id="uma-introdução-ao-compose">Uma Introdução ao Compose</h1>
<p>O <strong>Compose</strong> é o novo sistema de UI do Android. Constrói e atualiza a tela em ciclos de <em>recomposição</em>, onde ele otimamente monta uma árvore de componentes e consegue identificar onde ocorreu uma mudança de estado para recompor somente os elementos afetados pelo estado alterado.</p>
<p><strong>Composable</strong>: é a forma de declararmos funções que geram UI para o Compose. Essas funções não possuem retorno, mas podem receber parâmetros. Todo composable deve ser anotado com <em>@Composable</em>.</p>
<p>Os composables devem ser funções idempotentes, isto é, pra um mesmo conjunto de parâmetros de entrada devem gerar um mesmo composable (ou seja, devemos tratar os parâmetros para gerar UI, e não usar variáveis globais, valores randômicos ou contadores dentro de um composable).</p>
<p>Aqui temos um exemplo de como setar o compose numa activity:</p>
<pre><code class="language-kotlin">class MainActivity : ComponentActivity() {
     override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
           HelloWorldAppTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colors.surface
                ) {
                    HelloWorldScreen()
                }
            }
        }
    }
}

@Composable
fun HelloWorldScreen() {
    Column {
        Text(“Hello World”)
    }
}
</code></pre>
<br/>
<p>Pra colocar o compose num Fragment, o processo se dá no <em>onCreateView</em></p>
<pre><code class="language-kotlin">class MyFragment: Fragment() {
    [...]
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View { 
        return ComposeView(requireContext()).apply {
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                HelloWorldAppTheme {
                    HelloScreen()
                }
            }
        }
    }

    [...]
}

@Composable
fun HelloScreen() {
    Column {
        Text(&quot;Hello World&quot;)
    }
}
</code></pre>
<br/>
<blockquote>
<p>Obs: é prática comum que o primeiro composable de uma <em>Activity</em> ou <em>Fragment</em> represente a tela toda e que a partir dele se chamem os outros composables</p>
</blockquote>
<h2 id="componentes-de-ui-fundamentais">Componentes de UI Fundamentais</h2>
<h3 id="layout">Layout</h3>
<p>Componentes que visam o posicionamento dos elementos na tela</p>
<ul>
<li>Row</li>
<li>Column</li>
<li>Box</li>
<li>BoxWithConstraints</li>
<li>ConstraintLayout
<br/></li>
</ul>
<h3 id="foundation">Foundation</h3>
<p>Componentes de UI básicos</p>
<ul>
<li>Image</li>
<li>Text</li>
<li>BaseTextField</li>
<li>LazyColumn</li>
<li>LazyRow</li>
<li>Shape</li>
<li>entre outros
<br/></li>
</ul>
<h4 id="material">Material</h4>
<p>Componentes do material design (a maioria da UI vem daqui). Para mais detalhes sobre esses composables e outros não incluídos na listagem, acesse esse <a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#top-level-functions">link</a>, que te leva direto para uma página que contém diversos desses composables do Material e como utilizá-los. Caso queira mais detalhes sobre o Material como design system, acesse <a href="https://m2.material.io">Material 2</a> ou <a href="https://m3.material.io">Material 3</a></p>
<ul>
<li>AlertDialog</li>
<li>Button</li>
<li>Card</li>
<li>CircularProgressIndicator</li>
<li>DropdownMenu</li>
<li>Checkbox</li>
<li>FloatingActionButton</li>
<li>LinearProgressIndicator</li>
<li>ModalDrawer</li>
<li>RadioButton</li>
<li>Scaffold</li>
<li>Slider</li>
<li>Snackbar</li>
<li>Switch</li>
<li>TextField</li>
<li>TopAppBar</li>
<li>BottomNavigation
<br/></li>
</ul>
<h2 id="detalhes-de-layout">Detalhes de layout</h2>
<p><strong>Row</strong>: coloca os composables em uma linha, os adicionando no eixo horizontal da esquerda para a direita. Equivale ao <em>LinearLayout com orientação horizontal</em></p>
<pre><code class="language-kotlin">Row {
	// composables
}
</code></pre>
<br/>
<p><strong>Column</strong>: coloca os composables em coluna, os adicionando no eixo vertical de cima para baixo. Equivale ao <em>LinearLayout com orientação vertical</em></p>
<pre><code class="language-kotlin">Column {
    // composables
}
</code></pre>
<br/>
<p><strong>Box</strong>: alinha os composables empilhando-os num eixo de profundidade de trás pra frente, com os componentes mais recentes sobre os mais antigos na ordem de chamada (spoiler: dá pra modificar isso com o modificador <em>zIndex</em>). Equivale ao <em>FrameLayout</em></p>
<pre><code class="language-kotlin">Box {
	// composables
}
</code></pre>
<br/>
<p><strong>BoxWithConstraints</strong>: mesma coisa que o <em>Box</em>, só que com esse composable é possível pegar dimensões como largura ou altura. O exemplo abaixo foi tirado de <a href="https://foso.github.io/Jetpack-Compose-Playground/foundation/layout/boxwithconstraints/">Jetpack Compose Playground</a></p>
<pre><code class="language-kotlin">@Composable
fun BoxWithConstraintsDemo() {
    Column {
        Column {
            MyBoxWithConstraintsDemo()
        }

        Text(&quot;Here we set the size to 150.dp&quot;, modifier = Modifier.padding(top = 20.dp))
        Column(modifier = Modifier.size(150.dp)) {
            MyBoxWithConstraintsDemo()
        }
    }
}

@Composable
private fun MyBoxWithConstraintsDemo() {
    BoxWithConstraints {
        val boxWithConstraintsScope = this
        //You can use this scope to get the minWidth, maxWidth, minHeight, maxHeight in dp and constraints

        Column {
            if (boxWithConstraintsScope.maxHeight &gt;= 200.dp) {
                Text(
                    &quot;This is only visible when the maxHeight is &gt;= 200.dp&quot;,
                    style = TextStyle(fontSize = 20.sp)
                )
            }
            Text(&quot;minHeight: ${boxWithConstraintsScope.minHeight}, maxHeight: ${boxWithConstraintsScope.maxHeight},  minWidth: ${boxWithConstraintsScope.minWidth} maxWidth: ${boxWithConstraintsScope.maxWidth}&quot;)
        }
    }
}
</code></pre>
<br/>
<p><strong>ConstraintLayout</strong>: o sistema do compose que faz uso de recomposição é eficiente o suficiente pra que a gente não se preocupe com aninhamento de “views”, então é possível construir tudo de layout com <em>Rows</em>, <em>Columns</em> e <em>Boxes</em>. Mas caso a UI seja muito complexa. existe também a opção de usarmos o <em>ConstraintLayout</em>, este último só não oferece nenhuma vantagem de performance como no sistema de views anterior.</p>
<blockquote>
<p>Obs: é necessário incluir uma lib específica do constraint layout compose no build.gradle do módulo: <code>implementation 'androidx.constraintlayout:constraintlayout-compose:1.0.1'</code>.</p>
</blockquote>
<p>Abaixo temos um exemplo muito simples de alinhamento entre dois componentes onde o botão fica centralizado e abaixo da imagem</p>
<pre><code class="language-kotlin">ConstraintLayout {
    val (image, button) = createRefs()
    Image(
        painter = painterResource(R.drawable.your_drawable)
        modifier = Modifier
            .constrainAs(image) {
                top.linkTo(parent.top)
                start.linkTo(parent.start)
            }
    )
    Button(
        onClick = {},
        modifier = Modifier
            .constrainAs(button) {
            	top.linkTo(image.bottom)
                start.linkTo(image.start)
                end.linkTo(image.end)
            }
    ) {
        Text(&quot;Click Me!&quot;)
    }
}
</code></pre>
<br/>
<blockquote>
<p>Aproveitando a deixa, para carregarmos imagens a partir de URL's, a Google indica duas libs: <em>Coil</em> ou <em>Glide</em>. A lib <em>Coil</em> é a mais frequentemente utilizada pela comunidade, inclusive em tutoriais. No <em>build.gradle</em> do módulo devemos inserir a seguinte dependência: <code>implementation(&quot;io.coil-kt:coil-compose:2.2.2&quot;)</code>.
Para usarmos no compose, chamamos o composable <em>AsyncImage</em>, cujos principais parâmetros são <em>model</em>, que recebe a URL, e <em>contentDescription</em>, que pode ser um texto descrevendo o que temos na imagem.</p>
<pre><code class="language-kotlin">AsyncImage(
    model = &quot;url da imagem aqui&quot;,
    contentDescription = &quot;texto descritivo da imagem aqui&quot;
)
</code></pre>
</blockquote>
<h2 id="modifiers">Modifiers</h2>
<p>Os modifiers são modificadores que vão determinar como um composable é desenhado. Todos os composables fundamentais possuem esse parâmetro.</p>
<pre><code class="language-kotlin">Box(
    modifier = Modifier
        .modifier0()
        .modifier1()
        .modifier2()
        .modifier3()
        [...]
        .modifierN()
)
</code></pre>
<br/>
Os modifiers são aplicados na ordem em que são definidos, e podem ser repetidos. Por exemplo, podemos aplicar o modifier de padding uma ou mais vezes na cadeia de modifiers, porém a ordem em que eles são definidos muda a forma que o composable é desenhado.
<p>Dentre os modifiers, os mais usados são:</p>
<ul>
<li><p><strong>width</strong>: define a largura do composable, se não for definido o tamanho se limita ao seu conteúdo.</p>
</li>
<li><p><strong>height</strong>: define a altura do composable, se não for definido o tamanho se limita ao seu conteúdo.</p>
</li>
<li><p><strong>size</strong>: com os parâmetros <em>width</em> e <em>height</em>, definem o tamanho do composable, se um deles for omitido, a dimensão se limita ao seu conteúdo</p>
</li>
<li><p><strong>widthIn</strong> e <strong>heightIn</strong>: são modifiers que limitam o composable a dimensões mínimas (setando o parâmetro <em>min</em>) e/ou máximas (setando o  parâmetro <em>max</em>)</p>
</li>
<li><p><strong>fillMaxSize()</strong>, <strong>fillMaxWidth()</strong> e <strong>fillMaxHeight()</strong>: o composable toma todo espaço disponível, toda largura ou toda altura, respectivamente.</p>
</li>
<li><p><strong>padding</strong>: determina um espaçamento pro composable. Pra setar um espaçamento em um ou mais cantos do componente, é necessário atribuir um valor ao seu respectivo parâmetro nomeado - e são eles: <em>top</em>, <em>start</em>, <em>end</em>, <em>bottom</em> e <em>all</em>. Se um parâmetro nomeado não for chamado, ele aplica o espaçamento definido em todos os cantos do composable, ou seja, é como se setasse o <em>all</em> implicitamente.</p>
</li>
<li><p><strong>offset</strong>: determina onde num eixo (x, y) o componente vai começar a ser desenhado. A principal diferença desse modificador para o padding é que o padding faz parte do componente, o espaçamento do offset não. Além disso, o offset só pode definir o espaçamento à esquerda, setando o <em>x</em>, e/ou o superior, setando o <em>y</em>.</p>
</li>
</ul>
<pre><code class="language-kotlin">Modifier
    .offset(x = 2.dp)
    .padding(
        top = 5.dp,
        start = 4.dp
    )
</code></pre>
<blockquote>
<p>Vale notar que por padrão não temos margens nos composables, então as formas de definirmos espaçamentos são ou com o modifier <em>padding</em> ou usando o composable <em>Spacer</em> (este pra definir espaçamento entre composables - é só um composable preenchedor de espaço). O modifier <em>offset</em> também é uma opção, dado seus limites.</p>
</blockquote>
<ul>
<li><p><strong>zIndex</strong>: é capaz de modificar a profundidade de um composable desenhado na tela, o trazendo pra frente de outros composables ou o levando pra trás.</p>
</li>
<li><p><strong>border</strong>: define a borda do composable, devendo passar a espessura, a cor e opcionalmente um <em>Shape</em></p>
</li>
<li><p><strong>clip</strong>: determina o corte ou formato do composable a partir de um <em>Shape</em>. Por Exemplo, se passarmos um <code>RoundCornerShape(8.dp)</code> teremos um composable com bordas arredondadas de raio 8dp</p>
</li>
<li><p><strong>background</strong>: define o fundo do composable</p>
</li>
<li><p><strong>then</strong>: é um modificador especial que permite que chamemos outro modificador em cadeia - geralmente definido como parâmetro do composable - aplicando todos os modificadores definidos nesse modifier chamado. No exemplo abaixo, vemos que o <em>background</em> é aplicado após a definição do tamanho da <em>Column</em>.</p>
</li>
</ul>
<pre><code class="language-kotlin">@Composable
fun ExampleWithModifier(
    modifier: Modifier = Modifier
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .then(modifier)
    )
}

@Composable
fun ExampleCallingAboveComponent() {
    ExampleWithModifier(
        modifier = Modifier.background(Color.Blue)
    )
}
</code></pre>
<br/>
<h2 id="o-que-temos-por-vir">O que temos por vir</h2>
<p>Ainda há muitos pontos a serem discutidos, como: manipulação de estado, animações, navegação, injeção de dependência, arquitetura, melhores práticas, etc, etc, etc. Mas só pra termos um exemplo de como é uma animação, temos aqui dois códigos extraídos do <a href="https://developer.android.com/jetpack/compose/animation">Android Developers</a>, demonstrando uma animação de valor e uma animação de visibilidade, respectivamente. A animação de valor está definindo a opacidade do composable de acordo com um condicional (<strong>enabled</strong>) e a animação de visibilidaade faz uso das transições <code>fadeIn()</code> e <code>fadeOut()</code> pra animar visibilidade dos fundos, transicionando entre as cores azul e cinza.</p>
<pre><code class="language-kotlin">val alpha: Float by animateFloatAsState(if (enabled) 1f else 0.5f)
Box(
    Modifier.fillMaxSize()
        .graphicsLayer(alpha = alpha)
        .background(Color.Red)
)
</code></pre>
<pre><code class="language-kotlin">AnimatedVisibility(
    visible = visible,
    enter = fadeIn(),
    exit = fadeOut()
) { // this: AnimatedVisibilityScope
    // Use AnimatedVisibilityScope#transition to add a custom animation
    // to the AnimatedVisibility.
    val background by transition.animateColor { state -&gt;
        if (state == EnterExitState.Visible) Color.Blue else Color.Gray
    }
    Box(modifier = Modifier.size(128.dp).background(background))
}
</code></pre>
